---
title: 【C#で学ぶ】応用情報技術者試験のためのアルゴリズム入門：ヒープソート編
tags:
  - C#
  - アルゴリズム
  - 応用情報技術者試験
  - ヒープソート
private: false
updated_at: '2025-04-10T09:23:26+09:00'
id: d472b111ff7ded50f02b
organization_url_name: null
slide: false
ignorePublish: false
---
こんにちは！応用情報技術者試験（AP）の受験者向けに、これまで[探索](https://qiita.com/izutani/items/a701cdec50bc58fe9a74)や[ソート](https://qiita.com/izutani/items/7a0465adbd0dc4939b50)アルゴリズムを解説してきました。今回は「ヒープソート」を取り上げます。ヒープというデータ構造を活用した面白いアルゴリズムで、試験でも出題される可能性があります。C#での実装とともに学びましょう！

# ヒープソートとは？
ヒープソートは、ヒープと呼ばれる特殊な二分木構造を利用してデータを整列するアルゴリズムです。ヒープには「最大ヒープ」（親ノードが子ノードより大きい）と「最小ヒープ」（親ノードが子ノードより小さい）の2種類がありますが、今回は最大ヒープを使った昇順ソートを解説します。

### ヒープソートの流れ
1. 配列を最大ヒープに変換する（ヒープ化）
2. ヒープの根（最大値）を配列の末尾に移動し、ヒープのサイズを縮小
3. 残りの部分を再びヒープ化し、2を繰り返す

### 特徴
* **時間計算量**: O(n log n)（nは要素数）
* **メリット**: 安定した性能、追加のメモリをほとんど使わない（インプレースソート）
* **デメリット**: 実装がやや複雑、他のO(n log n)のアルゴリズム（例: クイックソート）に比べて定数倍が大きい

# C#での実装例
以下は、配列を昇順に整列するヒープソートのコードです。最大ヒープを利用します。

```csharp
using System;

class Program
{
    static void HeapSort(int[] array)
    {
        int n = array.Length;

        // 配列全体を最大ヒープに変換
        for (int i = n / 2 - 1; i >= 0; i--)
        {
            Heapify(array, n, i);
        }

        // ヒープから1つずつ最大値を末尾に移動
        for (int i = n - 1; i > 0; i--)
        {
            // 根（最大値）を末尾に移動
            int temp = array[0];
            array[0] = array[i];
            array[i] = temp;

            // 残りの部分をヒープ化
            Heapify(array, i, 0);
        }
    }

    static void Heapify(int[] array, int n, int i)
    {
        int largest = i; // 親ノード
        int left = 2 * i + 1; // 左の子
        int right = 2 * i + 2; // 右の子

        // 左の子が親より大きい場合
        if (left < n && array[left] > array[largest])
        {
            largest = left;
        }

        // 右の子が親より大きい場合
        if (right < n && array[right] > array[largest])
        {
            largest = right;
        }

        // largestが親と異なる場合、交換して再帰的にヒープ化
        if (largest != i)
        {
            int temp = array[i];
            array[i] = array[largest];
            array[largest] = temp;

            Heapify(array, n, largest);
        }
    }

    static void Main()
    {
        int[] numbers = { 5, 3, 8, 4, 2 };
        Console.WriteLine("ソート前: " + string.Join(", ", numbers));

        HeapSort(numbers);
        Console.WriteLine("ソート後: " + string.Join(", ", numbers));
    }
}
```

### 実行結果
```text
ソート前: 5, 3, 8, 4, 2
ソート後: 2, 3, 4, 5, 8
```

# ヒープソートの仕組みをステップで解説
### 初期配列: [5, 3, 8, 4, 2]
1. **ヒープ化**
配列を最大ヒープに変換します。結果: `[8, 4, 5, 3, 2]`
（8が根、左右の子がそれより小さい）
2. **最大値を末尾に移動**
8を末尾に移動し、残りをヒープ化: `[5, 4, 2, 3, 8]`
3. **繰り返し**
5を末尾に移動し、残りをヒープ化…と続け、最終的に`[2, 3, 4, 5, 8]`に。
このように、ヒープの性質を利用して効率的にソートが進みます。

# 試験対策のポイント
1. **ヒープの性質を理解する**
最大ヒープでは「親 ≥ 子」が常に成り立ちます。このルールが崩れないよう、ヒープ化（Heapify）の処理が重要です。
2. **時間計算量を覚える**
ヒープ化にO(n)、ソート全体にO(n log n)かかることを押さえましょう。試験で計算量を問われたら自信を持って答えられます。
3. **疑似コードに慣れる**
試験ではC#ではなく疑似コードで出題されることも。`Heapify`の再帰的な動きを頭で追えるように練習してください。

# おわりに
ヒープソートは、ヒープというデータ構造を活かしたユニークなアルゴリズムです。応用情報技術者試験では直接出題される頻度は高くありませんが、理解しておくとアルゴリズム全体の視野が広がります。ぜひコードを実行し、配列がどう変化するか確認してみてください。ともに頑張りましょう！
